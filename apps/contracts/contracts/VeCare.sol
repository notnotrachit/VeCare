// SPDX-License-Identifier: MIT

//                                      #######
//                                 ################
//                               ####################
//                             ###########   #########
//                            #########      #########
//          #######          #########       #########
//          #########       #########      ##########
//           ##########     ########     ####################
//            ##########   #########  #########################
//              ################### ############################
//               #################  ##########          ########
//                 ##############      ###              ########
//                  ############                       #########
//                    ##########                     ##########
//                     ########                    ###########
//                       ###                    ############
//                                          ##############
//                                    #################
//                                   ##############
//                                   #########

pragma solidity ^0.8.19;

import '@openzeppelin/contracts/access/AccessControl.sol';
import './interfaces/IX2EarnRewardsPool.sol';
import '@openzeppelin/contracts/utils/Strings.sol';

/**
 * @title VeCare Contract
 * @dev Medical crowdfunding platform with AI verification and B3tr token rewards
 * 
 * Key Features:
 * - AI-verified medical campaigns
 * - Direct fund transfers to campaign creators
 * - B3tr token rewards for donors
 * - Transparent on-chain tracking
 * - Trust score system for creators
 */
contract VeCare is AccessControl {
    // The X2EarnRewardsPool contract used to distribute B3tr rewards to donors
    IX2EarnRewardsPool public x2EarnRewardsPoolContract;

    // AppID given by the X2EarnApps contract of VeBetterDAO
    bytes32 public appId;

    // Campaign structure
    struct Campaign {
        uint256 id;
        address payable creator;
        string title;
        string description;
        string medicalDocumentHash; // IPFS hash of medical documents
        uint256 goalAmount;
        uint256 raisedAmount;
        uint256 deadline;
        bool isActive;
        bool isVerified;
        bool fundsWithdrawn;
        uint256 createdAt;
        uint256 donorCount;
    }

    // Creator profile with trust score
    struct CreatorProfile {
        uint256 totalCampaigns;
        uint256 successfulCampaigns;
        uint256 totalRaised;
        uint256 trustScore; // 0-100
        uint256 lastUpdateTimestamp;
        bool exists;
    }

    // Campaign counter
    uint256 public campaignCounter;

    // Mapping from campaign ID to Campaign
    mapping(uint256 => Campaign) public campaigns;

    // Mapping from campaign ID to donor addresses and amounts
    mapping(uint256 => mapping(address => uint256)) public donations;

    // Mapping from creator address to CreatorProfile
    mapping(address => CreatorProfile) public creatorProfiles;

    // Mapping from campaign ID to update count (for trust score calculation)
    mapping(uint256 => uint256) public campaignUpdates;

    // B3tr rewards per donation (in wei per VET donated)
    uint256 public b3trRewardRate = 1e18; // 1 B3TR per 1 VET donated

    // Platform fee percentage (in basis points, e.g., 250 = 2.5%)
    uint256 public platformFeePercentage = 250; // 2.5%

    // Accumulated platform fees
    uint256 public accumulatedFees;

    // Events
    event CampaignCreated(
        uint256 indexed campaignId,
        address indexed creator,
        string title,
        uint256 goalAmount,
        uint256 deadline
    );
    
    event CampaignVerified(uint256 indexed campaignId, bool verified);
    
    event DonationReceived(
        uint256 indexed campaignId,
        address indexed donor,
        uint256 amount,
        uint256 b3trReward
    );
    
    event FundsWithdrawn(
        uint256 indexed campaignId,
        address indexed creator,
        uint256 amount
    );
    
    event CampaignUpdated(
        uint256 indexed campaignId,
        string updateMessage
    );
    
    event TrustScoreUpdated(
        address indexed creator,
        uint256 newScore
    );

    /**
     * @dev Constructor for the VeCare contract
     * @param _admin Address of the admin
     * @param _x2EarnRewardsPoolContract Address of the X2EarnRewardsPool contract
     * @param _appId The appId generated by the X2EarnApps contract
     */
    constructor(
        address _admin,
        address _x2EarnRewardsPoolContract,
        bytes32 _appId
    ) {
        require(_admin != address(0), 'VeCare: admin address cannot be zero');
        require(_x2EarnRewardsPoolContract != address(0), 'VeCare: x2EarnRewardsPool address cannot be zero');

        x2EarnRewardsPoolContract = IX2EarnRewardsPool(_x2EarnRewardsPoolContract);
        appId = _appId;
        _grantRole(DEFAULT_ADMIN_ROLE, _admin);
    }

    /**
     * @dev Create a new medical campaign
     * @param _title Campaign title
     * @param _description Campaign description
     * @param _medicalDocumentHash IPFS hash of medical documents
     * @param _goalAmount Fundraising goal in wei
     * @param _durationDays Campaign duration in days
     */
    function createCampaign(
        string memory _title,
        string memory _description,
        string memory _medicalDocumentHash,
        uint256 _goalAmount,
        uint256 _durationDays
    ) external returns (uint256) {
        require(bytes(_title).length > 0, 'VeCare: Title cannot be empty');
        require(bytes(_medicalDocumentHash).length > 0, 'VeCare: Medical documents required');
        require(_goalAmount > 0, 'VeCare: Goal amount must be greater than 0');
        require(_durationDays > 0 && _durationDays <= 365, 'VeCare: Invalid duration');

        campaignCounter++;
        uint256 deadline = block.timestamp + (_durationDays * 1 days);

        campaigns[campaignCounter] = Campaign({
            id: campaignCounter,
            creator: payable(msg.sender),
            title: _title,
            description: _description,
            medicalDocumentHash: _medicalDocumentHash,
            goalAmount: _goalAmount,
            raisedAmount: 0,
            deadline: deadline,
            isActive: true,
            isVerified: false,
            fundsWithdrawn: false,
            createdAt: block.timestamp,
            donorCount: 0
        });

        // Initialize creator profile if doesn't exist
        if (!creatorProfiles[msg.sender].exists) {
            creatorProfiles[msg.sender] = CreatorProfile({
                totalCampaigns: 1,
                successfulCampaigns: 0,
                totalRaised: 0,
                trustScore: 50, // Start with neutral score
                lastUpdateTimestamp: block.timestamp,
                exists: true
            });
        } else {
            creatorProfiles[msg.sender].totalCampaigns++;
        }

        emit CampaignCreated(
            campaignCounter,
            msg.sender,
            _title,
            _goalAmount,
            deadline
        );

        return campaignCounter;
    }

    /**
     * @dev Verify a campaign (AI verification result)
     * @param _campaignId Campaign ID
     * @param _verified Verification status
     */
    function verifyCampaign(uint256 _campaignId, bool _verified) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        Campaign storage campaign = campaigns[_campaignId];
        require(campaign.isActive, 'VeCare: Campaign is not active');

        campaign.isVerified = _verified;

        emit CampaignVerified(_campaignId, _verified);
    }

    /**
     * @dev Donate to a campaign
     * @param _campaignId Campaign ID
     */
    function donate(uint256 _campaignId) external payable {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        Campaign storage campaign = campaigns[_campaignId];
        
        require(campaign.isActive, 'VeCare: Campaign is not active');
        require(campaign.isVerified, 'VeCare: Campaign is not verified');
        require(block.timestamp < campaign.deadline, 'VeCare: Campaign has ended');
        require(msg.value > 0, 'VeCare: Donation must be greater than 0');

        // Track donation
        if (donations[_campaignId][msg.sender] == 0) {
            campaign.donorCount++;
        }
        donations[_campaignId][msg.sender] += msg.value;
        campaign.raisedAmount += msg.value;

        // Calculate B3tr reward for donor
        uint256 b3trReward = (msg.value * b3trRewardRate) / 1e18;

        // Distribute B3tr reward to donor if available
        if (b3trReward > 0 && x2EarnRewardsPoolContract.availableFunds(appId) >= b3trReward) {
            try x2EarnRewardsPoolContract.distributeReward(
                appId,
                b3trReward,
                msg.sender,
                string.concat('Donation to campaign #', Strings.toString(_campaignId))
            ) {
                // Reward distributed successfully
            } catch {
                // Continue even if reward distribution fails
            }
        }

        emit DonationReceived(_campaignId, msg.sender, msg.value, b3trReward);
    }

    /**
     * @dev Withdraw funds from a campaign (creator only)
     * @param _campaignId Campaign ID
     */
    function withdrawFunds(uint256 _campaignId) external {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        Campaign storage campaign = campaigns[_campaignId];
        
        require(msg.sender == campaign.creator, 'VeCare: Only creator can withdraw');
        require(campaign.isVerified, 'VeCare: Campaign must be verified');
        require(!campaign.fundsWithdrawn, 'VeCare: Funds already withdrawn');
        require(
            block.timestamp >= campaign.deadline || campaign.raisedAmount >= campaign.goalAmount,
            'VeCare: Campaign still active'
        );
        require(campaign.raisedAmount > 0, 'VeCare: No funds to withdraw');

        campaign.fundsWithdrawn = true;
        campaign.isActive = false;

        // Calculate platform fee
        uint256 fee = (campaign.raisedAmount * platformFeePercentage) / 10000;
        uint256 creatorAmount = campaign.raisedAmount - fee;

        accumulatedFees += fee;

        // Update creator profile
        CreatorProfile storage profile = creatorProfiles[campaign.creator];
        profile.totalRaised += creatorAmount;
        if (campaign.raisedAmount >= campaign.goalAmount) {
            profile.successfulCampaigns++;
        }

        // Transfer funds to creator
        (bool success, ) = campaign.creator.call{value: creatorAmount}('');
        require(success, 'VeCare: Transfer failed');

        emit FundsWithdrawn(_campaignId, campaign.creator, creatorAmount);
    }

    /**
     * @dev Post an update to a campaign (increases trust score)
     * @param _campaignId Campaign ID
     * @param _updateMessage Update message
     */
    function postCampaignUpdate(uint256 _campaignId, string memory _updateMessage) external {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        Campaign storage campaign = campaigns[_campaignId];
        
        require(msg.sender == campaign.creator, 'VeCare: Only creator can post updates');
        require(bytes(_updateMessage).length > 0, 'VeCare: Update message cannot be empty');

        campaignUpdates[_campaignId]++;

        // Increase trust score for posting updates
        CreatorProfile storage profile = creatorProfiles[msg.sender];
        if (profile.trustScore < 100) {
            profile.trustScore = profile.trustScore + 1 > 100 ? 100 : profile.trustScore + 1;
            profile.lastUpdateTimestamp = block.timestamp;
            emit TrustScoreUpdated(msg.sender, profile.trustScore);
        }

        emit CampaignUpdated(_campaignId, _updateMessage);
    }

    /**
     * @dev Withdraw platform fees (admin only)
     * @param _recipient Recipient address
     */
    function withdrawPlatformFees(address payable _recipient) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(_recipient != address(0), 'VeCare: Invalid recipient');
        require(accumulatedFees > 0, 'VeCare: No fees to withdraw');

        uint256 amount = accumulatedFees;
        accumulatedFees = 0;

        (bool success, ) = _recipient.call{value: amount}('');
        require(success, 'VeCare: Transfer failed');
    }

    // ---------------- SETTERS ---------------- //

    /**
     * @dev Set B3tr reward rate
     * @param _rate New reward rate
     */
    function setB3trRewardRate(uint256 _rate) external onlyRole(DEFAULT_ADMIN_ROLE) {
        b3trRewardRate = _rate;
    }

    /**
     * @dev Set platform fee percentage
     * @param _percentage New fee percentage in basis points
     */
    function setPlatformFeePercentage(uint256 _percentage) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_percentage <= 1000, 'VeCare: Fee cannot exceed 10%');
        platformFeePercentage = _percentage;
    }

    /**
     * @dev Set appId
     * @param _appId New app ID
     */
    function setAppId(bytes32 _appId) external onlyRole(DEFAULT_ADMIN_ROLE) {
        appId = _appId;
    }

    /**
     * @dev Deactivate a campaign (admin only)
     * @param _campaignId Campaign ID
     */
    function deactivateCampaign(uint256 _campaignId) 
        external 
        onlyRole(DEFAULT_ADMIN_ROLE) 
    {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        campaigns[_campaignId].isActive = false;
    }

    // ---------------- GETTERS ---------------- //

    /**
     * @dev Get campaign details
     * @param _campaignId Campaign ID
     */
    function getCampaign(uint256 _campaignId) 
        external 
        view 
        returns (Campaign memory) 
    {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        return campaigns[_campaignId];
    }

    /**
     * @dev Get donation amount for a specific donor
     * @param _campaignId Campaign ID
     * @param _donor Donor address
     */
    function getDonation(uint256 _campaignId, address _donor) 
        external 
        view 
        returns (uint256) 
    {
        return donations[_campaignId][_donor];
    }

    /**
     * @dev Get creator profile
     * @param _creator Creator address
     */
    function getCreatorProfile(address _creator) 
        external 
        view 
        returns (CreatorProfile memory) 
    {
        return creatorProfiles[_creator];
    }

    /**
     * @dev Get campaign update count
     * @param _campaignId Campaign ID
     */
    function getCampaignUpdateCount(uint256 _campaignId) 
        external 
        view 
        returns (uint256) 
    {
        return campaignUpdates[_campaignId];
    }

    /**
     * @dev Check if campaign goal is reached
     * @param _campaignId Campaign ID
     */
    function isGoalReached(uint256 _campaignId) external view returns (bool) {
        require(_campaignId > 0 && _campaignId <= campaignCounter, 'VeCare: Invalid campaign ID');
        Campaign storage campaign = campaigns[_campaignId];
        return campaign.raisedAmount >= campaign.goalAmount;
    }

    /**
     * @dev Get active verified campaigns count
     */
    function getActiveVerifiedCampaignsCount() external view returns (uint256) {
        uint256 count = 0;
        for (uint256 i = 1; i <= campaignCounter; i++) {
            if (campaigns[i].isActive && campaigns[i].isVerified && block.timestamp < campaigns[i].deadline) {
                count++;
            }
        }
        return count;
    }

    // Receive function to accept VET
    receive() external payable {}
}
